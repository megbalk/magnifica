traits = names(df[, c("ln.zh", "ln.mpw.b", "ln.cw.m", "ln.cw.d",
"ln.ow.m", "ln.oh", "ln.c.side", "ln.o.side")])
##### TRIM DATASET ----
df.trim <- df %>%
dplyr::select(zooid.id, colony.id, formation, matches(traits))
colNums <- match(c(traits, "zooid.id"), names(df.trim))
df = as.data.frame(df.trim)
#ln.zh
sub.ln.zh <- sample(df[, traits[1]],
5000, replace = FALSE, prob = NULL)
shapiro.test(sub.ln.zh) #p-value < 2.2e-16
#ln.mpw.b
sub.ln.mpw.b <- sample(df[, traits[2]],
5000, replace = FALSE, prob = NULL)
shapiro.test(sub.ln.mpw.b) #p-value = 1.391e-07
#ln.cw.m
sub.ln.cw.m <- sample(df[, traits[3]],
5000, replace = FALSE, prob = NULL)
shapiro.test(sub.ln.cw.m) #p-value = 0.02664
#ln.cw.d
sub.ln.cw.d <- sample(df[, traits[4]],
5000, replace = FALSE, prob = NULL)
shapiro.test(sub.ln.cw.d) #p-value = 1.302e-05
#ln.ow.m
sub.ln.ow.m <- sample(df[, traits[5]],
5000, replace = FALSE, prob = NULL)
shapiro.test(sub.ln.ow.m) #p-value < 2.2e-16
#ln.oh
sub.ln.oh <- sample(df[, traits[6]],
5000, replace = FALSE, prob = NULL)
shapiro.test(sub.ln.oh) #p-value < 2.2e-16
#ln.c.side
sub.ln.c.side <- sample(df[, traits[7]],
5000, replace = FALSE, prob = NULL)
shapiro.test(sub.ln.c.side) #p-value = 0.001001
#ln.o.side
sub.ln.o.side <- sample(df[, traits[8]],
5000, replace = FALSE, prob = NULL)
shapiro.test(sub.ln.o.side) #p-value < 2.2e-16
#### REDUCE TO TRAITS OF INTEREST ----
trt_lg_N = c("formation", "colony.id", "zooid.id", traits)
dat_lg_N = df[intersect(colnames(df), trt_lg_N)]
head(dat_lg_N) #traits in same order as df and traits
mean_by_formation_colony = dat_lg_N %>% #use this going forward
dplyr::group_by(formation, colony.id) %>%
dplyr::summarize(n.zooid = length(zooid.id),
avg.zh = mean(ln.zh, na.rm = T),
sd.zh = sd(ln.zh, na.rm = T),
avg.mpw.b = mean(ln.mpw.b, na.rm = T),
sd.mpw.b = sd(ln.mpw.b, na.rm = T),
avg.cw.m = mean(ln.cw.m, na.rm = T),
sd.cw.m = sd(ln.cw.m, na.rm = T),
avg.cw.d = mean(ln.cw.d, na.rm = T),
sd.cw.d = sd(ln.cw.d, na.rm = T),
avg.ow.m = mean(ln.ow.m, na.rm = T),
sd.ow.m = sd(ln.ow.m, na.rm = T),
avg.oh = mean(ln.oh, na.rm = T),
sd.oh = sd(ln.oh, na.rm = T),
avg.o.side = mean(ln.o.side, na.rm = T),
sd.o.side = sd(ln.o.side, na.rm = T),
avg.c.side = mean(ln.c.side, na.rm = T),
sd.c.side = sd(ln.c.side, na.rm = T)) %>%
as.data.frame()
min(mean_by_formation_colony$n.zooid) #5
mean(mean_by_formation_colony$sd.zh) #0.09225405
range(mean_by_formation_colony$sd.zh) #0.02640565 0.57287376
mean(mean_by_formation_colony$sd.mpw.b) #0.1217314
range(mean_by_formation_colony$sd.mpw.b) #0.03438424 0.36673432
mean(mean_by_formation_colony$sd.cw.m) #0.1490322
range(mean_by_formation_colony$sd.cw.m) #0.01840786 0.36565782
mean(mean_by_formation_colony$sd.cw.d) #0.1103786
range(mean_by_formation_colony$sd.cw.d) #0.0219327 0.3552131
mean(mean_by_formation_colony$sd.ow.m) #0.07753377
range(mean_by_formation_colony$sd.ow.m) #0.01233698 0.31205832
mean(mean_by_formation_colony$sd.oh) #0.075358
range(mean_by_formation_colony$sd.oh) #0.0139018 0.2877568
mean(mean_by_formation_colony$sd.o.side) #0.08611018
range(mean_by_formation_colony$sd.o.side) #0.01430516 0.58861649
mean(mean_by_formation_colony$sd.c.side) #0.132877
range(mean_by_formation_colony$sd.c.side) #0.0353629 0.4793441
#means of means
mean_by_formation = mean_by_formation_colony %>%
dplyr::group_by(formation) %>%
dplyr::summarize(num.col = length(unique(colony.id)),
num.zooid = sum(n.zooid),
avg.zooid = mean(n.zooid),
avg.zh = mean(avg.zh, na.rm = T),
avg.mpw.b = mean(avg.mpw.b, na.rm = T),
avg.cw.m = mean(avg.cw.m, na.rm = T),
avg.cw.d = mean(avg.cw.d, na.rm = T),
avg.ow.m = mean(avg.ow.m, na.rm = T),
avg.oh = mean(avg.oh, na.rm = T),
avg.o.side = mean(avg.o.side, na.rm = T),
avg.c.side = mean(avg.c.side, na.rm = T)) %>%
as.data.frame()
colony_means = dat_lg_N %>%
dplyr::group_by(colony.id) %>%
dplyr::summarize(formation = formation[1],
n.zooid = length(unique(zooid.id)),
avg.zh = mean(ln.zh, na.rm = T),
avg.mpw.b = mean(ln.mpw.b, na.rm = T),
avg.cw.m = mean(ln.cw.m, na.rm = T),
avg.cw.d = mean(ln.cw.d, na.rm = T),
avg.ow.m = mean(ln.ow.m, na.rm = T),
avg.oh = mean(ln.oh, na.rm = T),
avg.o.side = mean(ln.o.side, na.rm = T),
avg.c.side = mean(ln.c.side, na.rm = T)) %>%
as.data.frame()
means = dat_lg_N %>%
dplyr::summarize(avg.zh = mean(ln.zh, na.rm = T),
avg.mpw.b = mean(ln.mpw.b, na.rm = T),
avg.cw.m = mean(ln.cw.m, na.rm = T),
avg.cw.d = mean(ln.cw.d, na.rm = T),
avg.ow.m = mean(ln.ow.m, na.rm = T),
avg.oh = mean(ln.oh, na.rm = T),
avg.o.side = mean(ln.o.side, na.rm = T),
avg.c.side = mean(ln.c.side, na.rm = T)) %>%
as.data.frame()
#### CHECK SAMPLE SIZES ----
## number of zooids per colony
range(mean_by_formation_colony$n.zooid)
#check number of zooids NOT colonies:
# by colonies use mean_by_formation_colony
# by zooid us dat_lg_N
col_form = split.data.frame(mean_by_formation_colony,  #by colonies
mean_by_formation_colony$formation) #zooids per formation
#just to look; max 328, smallest 19
col_form.n = lapply(col_form, function(x){dim(x)[1]})
#### SPLIT BY FORMATION ----
## by zooids:
by_form = split.data.frame(dat_lg_N,
dat_lg_N$formation)
#just to look; highest 7836, smallest 454
by_form.n = lapply(by_form, function(x){dim(x)[1]})
form_data = lapply(by_form, function(x) x[complete.cases(x),])
#### P MATRIX ----
p.cov = lapply(form_data, function (x){ (cov(x[, 4:11]))}) #traits per colony (not variation within colony)
##### P VARIANCES ----
##Phenotypic variance in traits and eigen vectors
Pmat = p.cov
lapply(Pmat, isSymmetric)  #is.symmetric.matrix
p.variances = lapply(Pmat, diag)
paste("Trait variances")
head(p.variances)
p.eig_variances = lapply(Pmat, function (x) {eigen(x)$values})
# lapply(Pmat, function (x) {eigen(x)})
paste("Eigenvalue variances")
head(p.eig_variances)
p.eig_percent = lapply(p.eig_variances, function (x) {x/sum(x)})
p.eig_per_mat = do.call(rbind, p.eig_percent)
p.eig_per_mat = data.frame(p.eig_per_mat, rownames(p.eig_per_mat))
p.eig_per = melt(p.eig_per_mat)
###### P NOISE ------
##Controlling for noise
#Extend G
P_ext = lapply(Pmat, function (x){ ExtendMatrix(x, ret.dim = 6)$ExtMat}) #not 8 because last eigen value (#8) was negative
#ignore warning from above
lapply(P_ext, isSymmetric)
P_Ext_std_variances = lapply(P_ext, diag)
P_Ext_eig_variances = lapply(P_ext, function (x) {eigen(x)$values})
p.comp_mat = RandomSkewers(P_ext) #need at least
p.corr_mat = p.comp_mat$correlations + t(p.comp_mat$correlations)
diag(p.corr_mat) = 1
paste("Random Skewers similarity matrix")
corrplot.mixed(p.corr_mat, upper = "number", lower = "pie")
##### PRIORS -----
#same as p.cov
phen.var = lapply(form_data, function (x){ (cov(x[, 4:11]))}) #traits of ALL; correct for colony later
prior = lapply(phen.var, function (x){list(G = list(G1 = list(V = x/2, nu = 2)),
R = list(V = x/4, nu = 2))})
load(file="./Results/g_matrices_data_form_reg.RData") #load the g matrices calculated above
model_G <- data.list[[1]]
dat_lg_N <- data.list[[2]]
form_data <- data.list[[3]]
mean_by_formation_colony <- data.list[[4]]
##### CHECK MODELS -----
formation_list #order of formations
summary(model_G[[1]])
###### POSTERIOR G MATRIX ------
#Retrieving G from posterior
g.model = model_G
ntraits = 8
Gmat = lapply(g.model, function (x) {
matrix(posterior.mode(x$VCV)[1:ntraits^2], ntraits, ntraits)})
#label lists as formations
names(Gmat) = names(by_form) #formation_list or form_data
# why aren't traits labeled??
for (i in seq_along(Gmat)){
colnames(Gmat[[i]]) <- traits
}
for (i in seq_along(Gmat)){
rownames(Gmat[[i]]) <- traits
}
diag(Gmat[[2]])
##### G VARIANCES -----
lapply(Gmat, isSymmetric)  #is.symmetric.matrix
g.variances = lapply(Gmat, diag)
paste("Trait variances")
head(g.variances)
###### G EIGEN ------
g.eig_variances = lapply(Gmat, function (x) {eigen(x)$values})
paste("Eigenvalue variances")
head(g.eig_variances)
g.eig_percent = lapply(g.eig_variances, function (x) {x/sum(x)})
g.eig_per_mat = do.call(rbind, g.eig_percent)
g.eig_per_mat = data.frame(g.eig_per_mat, rownames(g.eig_per_mat))
g.eig_per = melt(g.eig_per_mat)
#dev.off()
G_PC_dist = ggplot(g.eig_per,
aes(x = variable, y = value,
group = rownames.g.eig_per_mat.,
colour = rownames.g.eig_per_mat.)) +
geom_line(aes(linetype = rownames.g.eig_per_mat.)) +
geom_point() +
xlab("Principal component rank") +
ylab("%Variation in the PC")
###### G NOISE ------
##Controlling for noise
#Extend G
G_ext = lapply(Gmat, function (x){ ExtendMatrix(x, ret.dim = 6)$ExtMat}) #not 8 because last eigen value (#8) was negative
#ignore warning from above
lapply(G_ext, isSymmetric)
Ext_std_variances = lapply(G_ext, diag)
Ext_eig_variances = lapply(G_ext, function (x) {eigen(x)$values})
g.comp_mat = RandomSkewers(G_ext) #need at least
g.corr_mat = g.comp_mat$correlations + t(g.comp_mat$correlations)
diag(g.corr_mat) = 1
paste("Random Skewers similarity matrix")
corrplot.mixed(g.corr_mat,upper = "number", lower = "pie")
##### RANDOM SKEWERS OF P & G OF EACH FORMATION -----
#NKLS
NKLS_comp_mat = RandomSkewers(list(G_ext[[1]], P_ext[[1]])) #need at least
NKLS_corr_mat = NKLS_comp_mat$correlations + t(NKLS_comp_mat$correlations)
diag(NKLS_corr_mat) = 1
paste("Random Skewers similarity matrix")
corrplot.mixed(NKLS_corr_mat, upper = "number", lower = "pie")
#NKBS
NKBS_comp_mat = RandomSkewers(list(G_ext[[2]], P_ext[[2]])) #need at least
NKBS_corr_mat =NKBS_comp_mat$correlations + t(NKBS_comp_mat$correlations)
diag(NKBS_corr_mat) = 1
paste("Random Skewers similarity matrix")
corrplot.mixed(NKBS_corr_mat, upper = "number", lower = "pie")
#Tewkesbury
Tewkesbury_comp_mat = RandomSkewers(list(G_ext[[3]], P_ext[[3]])) #need at least
Tewkesbury_corr_mat = Tewkesbury_comp_mat$correlations + t(Tewkesbury_comp_mat$correlations)
diag(Tewkesbury_corr_mat) = 1
paste("Random Skewers similarity matrix")
corrplot.mixed(Tewkesbury_corr_mat, upper = "number", lower = "pie")
#Waipuru
Waipuru_comp_mat = RandomSkewers(list(G_ext[[4]], P_ext[[4]])) #need at least
Waipuru_corr_mat = Waipuru_comp_mat$correlations + t(Waipuru_comp_mat$correlations)
diag(Waipuru_corr_mat) = 1
paste("Random Skewers similarity matrix")
corrplot.mixed(Waipuru_corr_mat, upper = "number", lower = "pie")
#Upper Kai-Iwi
UKai_Iwi_comp_mat = RandomSkewers(list(G_ext[[5]], P_ext[[5]])) #need at least
UKai_Iwi_corr_mat = UKai_Iwi_comp_mat$correlations + t(UKai_Iwi_comp_mat$correlations)
diag(UKai_Iwi_corr_mat) = 1
paste("Random Skewers similarity matrix")
corrplot.mixed(UKai_Iwi_corr_mat, upper = "number", lower = "pie")
#Tainui
Tainui_comp_mat = RandomSkewers(list(G_ext[[6]], P_ext[[6]])) #need at least
Tainui_corr_mat = Tainui_comp_mat$correlations + t(Tainui_comp_mat$correlations)
diag(Tainui_corr_mat) = 1
paste("Random Skewers similarity matrix")
corrplot.mixed(Tainui_corr_mat, upper = "number", lower = "pie")
#SHCSBSB
SHCSBSB_comp_mat = RandomSkewers(list(G_ext[[7]], P_ext[[7]])) #need at least
SHCSBSB_corr_mat = SHCSBSB_comp_mat$correlations + t(SHCSBSB_comp_mat$correlations)
diag(SHCSBSB_corr_mat) = 1
paste("Random Skewers similarity matrix")
corrplot.mixed(SHCSBSB_corr_mat, upper = "number", lower = "pie")
##### COMPARISON OF PC1 AND PC2 OF P & G OF EACH FORMATION -----
g.eig_variances
p.eig_variances
g.eig_vectors <- lapply(Gmat, function (x) {eigen(x)$vectors})
paste("Eigenvalue vectors")
head(g.eig_vectors)
formations <- c("NKLS", "NKBS", "Tewkesbury",
"Waipuru", "Upper Kai-Iwi",
"Tainui", "SHCSBSB")
r.names <- c(rep(formations[1], 8),
rep(formations[2], 8),
rep(formations[3], 8),
rep(formations[4], 8),
rep(formations[5], 8),
rep(formations[6], 8),
rep(formations[7], 8))
g.eig_vect_mat = do.call(rbind, g.eig_vectors)
g.eig_vect_mat = data.frame(g.eig_vect_mat,
rownames = r.names)
g.eig_vect = melt(g.eig_vect_mat)
ggplot(g.eig_vect,
aes(x = variable, y = value,
group = rownames,
colour = rownames)) +
geom_line(aes(linetype = rownames)) +
geom_point() +
xlab("Principal component vector") +
ylab("%Variation in the PC")
# We start by generating "individuals" (i.e., colonies)
# in a population with VCV patterns corresponding to a known G.
# We then calculate VCV matrices for those individuals and obtain their
# similarity with the 'true' G.
repititions <- 200
#Defining the population size. Each population size is repeated 200 times.
#Starting at 2 individuals and going up to 100,
col_form.n # max 328, min 19
pop.size = sort(rep(c(2:500), repititions)) #make 500 so much bigger than max no. colonies
pop.dist <- lapply(pop.size, function (x){mvrnorm(n = x,
rep(0,8), # mean 0 for 8 traits
G_ext[[1]])}) # Simulate individual trait data based on the first VCOV matrix in our time series and different sample sizes.
# Calculate VCOV matrices
pop.cv <- lapply(pop.dist, cov)
# Estimate selection gradients based on Random Skewers, comparing our true
# G matrix and the undersampled pooled P matrix.
RS_result = RandomSkewers(pop.cv,
G_ext[[1]])
out_results <- cbind(RS_result$correlation, pop.size)
# Computing Random Skewers between pairs of actual G matrices in our data
#(n = 7 for 7 formations)
# sub-setting so that we only analyze the traits and formation of interest
mean.df.sub <- mean_by_formation_colony[, c(1, 4:11)]
#remove rows with NA so that the sample size gets correct when we plot
#the sample size for the VCOV.
mean.df_complete_cases <- mean.df.sub[complete.cases(mean.df.sub), ] #remove rows with NA so that the sample size gets correct when we plot the sample size for the VCOV.
# Calculating the sample size for each time point
colony_samples = split.data.frame(mean.df_complete_cases, mean.df_complete_cases$formation) #Sample size
sample_sizes_G = lapply(colony_samples, function(x){dim(x)[1]})
comp_sampleN = matrix(0, 7, 7) #calculating the smallest sample size in the comparison among pairs of G
for (i in 1:length(sample_sizes_G)){
for (j in 1:length(sample_sizes_G)){
comp_sampleN[i,j]=min(as.numeric(sample_sizes_G[i]),as.numeric(sample_sizes_G[j]))
}
}
# Here, we do the actual Random Skewers test and
# combined the results (correlations in the response to selection)
# with the smallest sample size for the pairs of G that are investigated
comp_mat = RandomSkewers(G_ext)
melt_comp = melt(comp_mat$correlations[lower.tri(comp_mat$correlations)])
melt_samples = melt(comp_sampleN[lower.tri(comp_sampleN)])
obs_melt = cbind(melt_comp, melt_samples)
colnames(obs_melt) = c("RS","N")
#Plotting the result
plot(out_results[, 2], out_results[, 1],
xlab = "Sample size", ylab = "Similarity",
pch = 19, col = "grey")
points(obs_melt$N, obs_melt$RS,
col = "#00BFC4", pch = 19) #color by formation
# Function to convert vector to norm length
f.normalize_vector <- function(vector) {
norm_length <- sqrt(sum(vector^2))
normalized_vector <- vector / norm_length
return(normalized_vector)
}
#trait means by time
mean_by_formation
NKLS <- as.numeric(mean_by_formation[1, 5:12]) # A vector containing trait means from sample/formation 1
NKBS <- as.numeric(mean_by_formation[2, 5:12]) # A vector containing trait means from sample/formation 2
tewk <- as.numeric(mean_by_formation[3, 5:12]) # A vector containing trait means from sample/formation 3
wai <- as.numeric(mean_by_formation[4, 5:12]) # A vector containing trait means from sample/formation 4
uki <- as.numeric(mean_by_formation[5, 5:12]) # A vector containing trait means from sample/formation 5
tai <- as.numeric(mean_by_formation[6, 5:12]) # A vector containing trait means from sample/formation 6
SHCSBSB <- as.numeric(mean_by_formation[7, 5:12]) # A vector containing trait means from sample/formation 7
## really need to learn how to name things in functions...
evolved_difference_unit_length_t1 <- f.normalize_vector(NKBS - NKLS)
evolved_difference_unit_length_t2 <- f.normalize_vector(tewk - NKBS)
evolved_difference_unit_length_t3 <- f.normalize_vector(wai - tewk)
evolved_difference_unit_length_t4 <- f.normalize_vector(uki - wai)
evolved_difference_unit_length_t5 <- f.normalize_vector(tai - uki)
evolved_difference_unit_length_t6 <- f.normalize_vector(SHCSBSB - tai)
G_matrix_NKLS = Gmat[[1]] # The G matrix estimated for sample/formation 1
G_matrix_NKBS = Gmat[[2]] # The G matrix estimated for sample/formation 2
G_matrix_tewk = Gmat[[3]] # The G matrix estimated for sample/formation 3
G_matrix_wai = Gmat[[4]] # The G matrix estimated for sample/formation 4
G_matrix_uki = Gmat[[5]] # The G matrix estimated for sample/formation 5
G_matrix_tai = Gmat[[6]] # The G matrix estimated for sample/formation 6
G_matrix_SHCSBSB = Gmat[[7]] # The G matrix estimated for sample/formation 7
### The evolvability in the direction of divergence from sample/formation 1 to sample/formation 2
#observed_evolvability_in_direction_of_change<-t(evolved_difference_unit_length)%*%as.matrix(G_matrix_1)%*%evolved_difference_unit_length
observed_evolvability_in_direction_of_change_t1 <- t(evolved_difference_unit_length_t1)%*%as.matrix(G_matrix_NKLS)%*%evolved_difference_unit_length_t1
observed_evolvability_in_direction_of_change_t2 <- t(evolved_difference_unit_length_t2)%*%as.matrix(G_matrix_NKBS)%*%evolved_difference_unit_length_t2
observed_evolvability_in_direction_of_change_t3 <- t(evolved_difference_unit_length_t3)%*%as.matrix(G_matrix_tewk)%*%evolved_difference_unit_length_t3
observed_evolvability_in_direction_of_change_t4 <- t(evolved_difference_unit_length_t4)%*%as.matrix(G_matrix_wai)%*%evolved_difference_unit_length_t4
observed_evolvability_in_direction_of_change_t5 <- t(evolved_difference_unit_length_t5)%*%as.matrix(G_matrix_uki)%*%evolved_difference_unit_length_t5
observed_evolvability_in_direction_of_change_t6 <- t(evolved_difference_unit_length_t6)%*%as.matrix(G_matrix_tai)%*%evolved_difference_unit_length_t6
### The conditional evolvability in the direction of divergence
#observed_conditional_evolvability_in_direction_of_change<-1/(t(evolved_difference_unit_length)%*%solve(as.matrix(G_matrix_1))%*%evolved_difference_unit_length)
observed_conditional_evolvability_in_direction_of_change_t1 <- 1/(t(evolved_difference_unit_length_t1)%*%solve(as.matrix(G_matrix_NKLS))%*%evolved_difference_unit_length_t1)
observed_conditional_evolvability_in_direction_of_change_t2 <- 1/(t(evolved_difference_unit_length_t2)%*%solve(as.matrix(G_matrix_NKBS))%*%evolved_difference_unit_length_t2)
observed_conditional_evolvability_in_direction_of_change_t3 <- 1/(t(evolved_difference_unit_length_t3)%*%solve(as.matrix(G_matrix_tewk))%*%evolved_difference_unit_length_t3)
observed_conditional_evolvability_in_direction_of_change_t4 <- 1/(t(evolved_difference_unit_length_t4)%*%solve(as.matrix(G_matrix_wai))%*%evolved_difference_unit_length_t4)
observed_conditional_evolvability_in_direction_of_change_t5 <- 1/(t(evolved_difference_unit_length_t5)%*%solve(as.matrix(G_matrix_uki))%*%evolved_difference_unit_length_t5)
observed_conditional_evolvability_in_direction_of_change_t6 <- 1/(t(evolved_difference_unit_length_t6)%*%solve(as.matrix(G_matrix_tai))%*%evolved_difference_unit_length_t6)
### Generate 10,000 selection gradients in random directions in the n-dimensional space
n_dimensions <- 8 # number of traits in G matrix
Beta <- randomBeta(10000, n_dimensions)
## check positive definite
is.symmetric.matrix(Beta)
# Compute the mean, minimum and maximum evolvability (e_mean, e_min, e_max) for a G matrix based on 10,000 random selection gradients
X_t1 <- evolvabilityBeta(as.matrix(G_matrix_NKLS), Beta)
sumX_t1 <- summary(X_t1) #provides you with info on mean, minimum and maximum evolvability  (e_mean, e_min, e_max) and conditional evolvability  (c_mean, c_min, c_max) for a given G matrix
X_t2 <- evolvabilityBeta(as.matrix(G_matrix_NKBS), Beta)
sumX_t2 <- summary(X_t2) #provides you with info on mean, minimum and maximum evolvability  (e_mean, e_min, e_max) and conditional evolvability  (c_mean, c_min, c_max) for a given G matrix
X_t3 <- evolvabilityBeta(as.matrix(G_matrix_tewk), Beta)
sumX_t3 <- summary(X_t3) #provides you with info on mean, minimum and maximum evolvability  (e_mean, e_min, e_max) and conditional evolvability  (c_mean, c_min, c_max) for a given G matrix
X_t4 <- evolvabilityBeta(as.matrix(G_matrix_wai), Beta)
sumX_t4 <- summary(X_t4) #provides you with info on mean, minimum and maximum evolvability  (e_mean, e_min, e_max) and conditional evolvability  (c_mean, c_min, c_max) for a given G matrix
X_t5 <- evolvabilityBeta(as.matrix(G_matrix_uki), Beta)
sumX_t5 <- summary(X_t5) #provides you with info on mean, minimum and maximum evolvability  (e_mean, e_min, e_max) and conditional evolvability  (c_mean, c_min, c_max) for a given G matrix
X_t6 <- evolvabilityBeta(as.matrix(G_matrix_tai), Beta)
sumX_t6 <- summary(X_t6) #provides you with info on mean, minimum and maximum evolvability  (e_mean, e_min, e_max) and conditional evolvability  (c_mean, c_min, c_max) for a given G matrix
X_t7 <- evolvabilityBeta(as.matrix(G_matrix_SHCSBSB), Beta)
sumX_t7 <- summary(X_t7) #provides you with info on mean, minimum and maximum evolvability  (e_mean, e_min, e_max) and conditional evolvability  (c_mean, c_min, c_max) for a given G matrix
X_sum <- data.frame(c.mean = c(sumX_t1$Averages[[3]], sumX_t2$Averages[[3]], sumX_t3$Averages[[3]],
sumX_t4$Averages[[3]], sumX_t5$Averages[[3]], sumX_t6$Averages[[3]],
sumX_t7$Averages[[3]]),
c.min = c(sumX_t1$Minimum[[3]], sumX_t2$Minimum[[3]], sumX_t3$Minimum[[3]],
sumX_t4$Minimum[[3]], sumX_t5$Minimum[[3]], sumX_t6$Minimum[[3]],
sumX_t7$Minimum[[3]]),
c.max = c(sumX_t1$Maximum[[3]], sumX_t2$Maximum[[3]], sumX_t3$Maximum[[3]],
sumX_t4$Maximum[[3]], sumX_t5$Maximum[[3]], sumX_t6$Maximum[[3]],
sumX_t7$Maximum[[3]]),
e.mean = c(sumX_t1$Averages[[1]], sumX_t2$Averages[[1]], sumX_t3$Averages[[1]],
sumX_t4$Averages[[1]], sumX_t5$Averages[[1]], sumX_t6$Averages[[1]],
sumX_t7$Averages[[1]]),
e.min = c(sumX_t1$Minimum[[1]], sumX_t2$Minimum[[1]], sumX_t3$Minimum[[1]],
sumX_t4$Minimum[[1]], sumX_t5$Minimum[[1]], sumX_t6$Minimum[[1]],
sumX_t7$Minimum[[1]]),
e.max = c(sumX_t1$Maximum[[1]], sumX_t2$Maximum[[1]], sumX_t3$Maximum[[1]],
sumX_t4$Maximum[[1]], sumX_t5$Maximum[[1]], sumX_t6$Maximum[[1]],
sumX_t7$Maximum[[1]]),
observed_e = c(observed_evolvability_in_direction_of_change_t1,
observed_evolvability_in_direction_of_change_t2,
observed_evolvability_in_direction_of_change_t3,
observed_evolvability_in_direction_of_change_t4,
observed_evolvability_in_direction_of_change_t5,
observed_evolvability_in_direction_of_change_t6,
""),
observed_c = c(observed_conditional_evolvability_in_direction_of_change_t1,
observed_conditional_evolvability_in_direction_of_change_t2,
observed_conditional_evolvability_in_direction_of_change_t3,
observed_conditional_evolvability_in_direction_of_change_t4,
observed_conditional_evolvability_in_direction_of_change_t5,
observed_conditional_evolvability_in_direction_of_change_t6,
""),
row.names = formation_list)
### Proportion of variance in n-dimensional trait space that is explained by PC1 (i.e., the first eigenvector)
#eigen(as.matrix(G_matrix_1))$values[1]/sum(eigen(as.matrix(G_matrix_1))$values)
eigen(as.matrix(G_matrix_NKLS))$values[1]/sum(eigen(as.matrix(G_matrix_NKLS))$values) #0.4676502
eigen(as.matrix(G_matrix_NKBS))$values[1]/sum(eigen(as.matrix(G_matrix_NKBS))$values) #0.5220323
eigen(as.matrix(G_matrix_tewk))$values[1]/sum(eigen(as.matrix(G_matrix_tewk))$values) #0.5024787
eigen(as.matrix(G_matrix_wai))$values[1]/sum(eigen(as.matrix(G_matrix_wai))$values) #0.400385
eigen(as.matrix(G_matrix_uki))$values[1]/sum(eigen(as.matrix(G_matrix_uki))$values) #0.7530483
eigen(as.matrix(G_matrix_tai))$values[1]/sum(eigen(as.matrix(G_matrix_tai))$values) #0.4238095
eigen(as.matrix(G_matrix_SHCSBSB))$values[1]/sum(eigen(as.matrix(G_matrix_SHCSBSB))$values) #0.5006772
### How much is the direction of Gmax (i.e., the direction first ) varying between different G-matrices?
Gmax_NKLS <- eigen(G_matrix_NKLS)$vectors[,1]
Gmax_NKBS <- eigen(G_matrix_NKBS)$vectors[,1]
Gmax_tewk <- eigen(G_matrix_tewk)$vectors[,1]
Gmax_wai <- eigen(G_matrix_wai)$vectors[,1]
Gmax_uki <- eigen(G_matrix_uki)$vectors[,1]
Gmax_tai <- eigen(G_matrix_tai)$vectors[,1]
Gmax_SHCSBSB <- eigen(G_matrix_SHCSBSB)$vectors[,1]
# Put Gmax to norm length
Gmax_NKLS_norm <- f.normalize_vector(Gmax_NKLS)
Gmax_NKBS_norm <- f.normalize_vector(Gmax_NKBS)
Gmax_tewk_norm <- f.normalize_vector(Gmax_tewk)
Gmax_wai_norm <- f.normalize_vector(Gmax_wai)
Gmax_uki_norm <- f.normalize_vector(Gmax_uki)
Gmax_tai_norm <- f.normalize_vector(Gmax_tai)
Gmax_SHCSBSB_norm <- f.normalize_vector(Gmax_SHCSBSB)
##Compute angles
# Calculate the dot product of the unit vectors
dot_product.Gmax_NKLS_NKBS <- sum(Gmax_NKLS_norm * Gmax_NKBS_norm)
# Calculate the angle in radians
angle_radians.Gmax_NKLS_NKBS <- acos(dot_product.Gmax_NKLS_NKBS)
# Convert the angle to degrees
angle_degrees.Gmax_NKLS_NKBS <- angle_radians.Gmax_NKLS_NKBS * (180 / pi)
dot_product.Gmax_NKBS_tewk <- sum(Gmax_NKBS_norm * Gmax_tewk_norm)
# Calculate the angle in radians
angle_radians.Gmax_NKBS_tewk <- acos(dot_product.Gmax_NKBS_tewk)
# Convert the angle to degrees
angle_degrees.Gmax_NKBS_tewk <- angle_radians.Gmax_NKBS_tewk * (180 / pi)
dot_product.Gmax_tewk_wai <- sum(Gmax_tewk_norm * Gmax_wai_norm)
# Calculate the angle in radians
angle_radians.Gmax_tewk_wai <- acos(dot_product.Gmax_tewk_wai)
# Convert the angle to degrees
angle_degrees.Gmax_tewk_wai <- angle_radians.Gmax_tewk_wai * (180 / pi)
dot_product.Gmax_wai_uki <- sum(Gmax_wai_norm * Gmax_uki_norm)
# Calculate the angle in radians
angle_radians.Gmax_wai_uki <- acos(dot_product.Gmax_wai_uki)
# Convert the angle to degrees
angle_degrees.Gmax_wai_uki <- angle_radians.Gmax_wai_uki * (180 / pi)
dot_product.Gmax_uki_tai <- sum(Gmax_uki_norm * Gmax_tai_norm)
# Calculate the angle in radians
angle_radians.Gmax_uki_tai <- acos(dot_product.Gmax_uki_tai)
# Convert the angle to degrees
angle_degrees.Gmax_uki_tai <- angle_radians.Gmax_uki_tai * (180 / pi)
dot_product.Gmax_tai_SHCSBSB <- sum(Gmax_tai_norm * Gmax_SHCSBSB_norm)
# Calculate the angle in radians
angle_radians.Gmax_tai_SHCSBSB <- acos(dot_product.Gmax_tai_SHCSBSB)
# Convert the angle to degrees
angle_degrees.Gmax_tai_SHCSBSB <- angle_radians.Gmax_tai_SHCSBSB * (180 / pi)
#dat_lg_N.com = dat_lg_N[complete.cases(dat_lg_N),] #didn't fix anything
phen.var.glob = cov(dat_lg_N[, 4:11]) #traits of ALL; correct for colony and formation later
prior.glob = list(G = list(G1 = list(V = phen.var.glob/2, nu = 10), #V same as individual G matrices; nu is different
G2 = list(V = phen.var.glob/2, nu = 10)), #additional V, made same as above
R = list(V = phen.var.glob/4, nu = 5)) #V same as individual G matrices
G_matrix_NKLS
X_t1
sumX_t1
